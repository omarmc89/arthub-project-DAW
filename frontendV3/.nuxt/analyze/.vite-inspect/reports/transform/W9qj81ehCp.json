{
  "resolvedId": "/Users/omarmartin/Documents/DAW/arthub-project-DAW/frontendV3/node_modules/@tanstack/virtual-core/dist/esm/index.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { memo, notUndefined, approxEqual } from \"./utils.js\";\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(element.getBoundingClientRect());\n  if (typeof ResizeObserver === \"undefined\") {\n    return () => {\n    };\n  }\n  const observer = new ResizeObserver((entries) => {\n    const entry = entries[0];\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n      const box = entry.borderBoxSize[0];\n      if (box) {\n        handler({ width: box.inlineSize, height: box.blockSize });\n        return;\n      }\n    }\n    handler(element.getBoundingClientRect());\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, {\n    passive: true\n  });\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb(element[instance.options.horizontal ? \"scrollLeft\" : \"scrollTop\"]);\n  };\n  handler();\n  element.addEventListener(\"scroll\", handler, {\n    passive: true\n  });\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n  };\n};\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb(element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"]);\n  };\n  handler();\n  element.addEventListener(\"scroll\", handler, {\n    passive: true\n  });\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]\n  );\n};\nconst windowScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.isScrolling = false;\n    this.isScrollingTimeoutId = null;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.measureElementCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        } else if (typeof ResizeObserver !== \"undefined\") {\n          return _ro = new ResizeObserver((entries) => {\n            entries.forEach((entry) => {\n              this._measureElement(entry.target, entry);\n            });\n          });\n        } else {\n          return null;\n        }\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.disconnect();\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\")\n          delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        scrollingDelay: 150,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = memo(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"maybeNotify\",\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.scrollElement = null;\n    };\n    this._didMount = () => {\n      this.measureElementCache.forEach(this.observer.observe);\n      return () => {\n        this.observer.disconnect();\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      const scrollElement = this.options.getScrollElement();\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        this.scrollElement = scrollElement;\n        this._scrollToOffset(this.scrollOffset, {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset) => {\n            this.scrollAdjustments = 0;\n            if (this.scrollOffset === offset) {\n              return;\n            }\n            if (this.isScrollingTimeoutId !== null) {\n              clearTimeout(this.isScrollingTimeoutId);\n              this.isScrollingTimeoutId = null;\n            }\n            this.isScrolling = true;\n            this.scrollDirection = this.scrollOffset < offset ? \"forward\" : \"backward\";\n            this.scrollOffset = offset;\n            this.maybeNotify();\n            this.isScrollingTimeoutId = setTimeout(() => {\n              this.isScrollingTimeoutId = null;\n              this.isScrolling = false;\n              this.scrollDirection = null;\n              this.maybeNotify();\n            }, this.options.scrollingDelay);\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.memoOptions = memo(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey\n      ],\n      (count, paddingStart, scrollMargin, getItemKey) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurements = memo(\n      () => [this.memoOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey }, itemSizeCache) => {\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = memo(\n      () => [this.getMeasurements(), this.getSize(), this.scrollOffset],\n      (measurements, outerSize, scrollOffset) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset\n        }) : null;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getIndexes = memo(\n      () => [\n        this.options.rangeExtractor,\n        this.calculateRange(),\n        this.options.overscan,\n        this.options.count\n      ],\n      (rangeExtractor, range, overscan, count) => {\n        return range === null ? [] : rangeExtractor({\n          ...range,\n          overscan,\n          count\n        });\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const item = this.measurementsCache[this.indexFromElement(node)];\n      if (!item || !node.isConnected) {\n        this.measureElementCache.forEach((cached, key) => {\n          if (cached === node) {\n            this.observer.unobserve(node);\n            this.measureElementCache.delete(key);\n          }\n        });\n        return;\n      }\n      const prevNode = this.measureElementCache.get(item.key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.measureElementCache.set(item.key, node);\n      }\n      const measuredItemSize = this.options.measureElement(node, entry, this);\n      this.resizeItem(item, measuredItemSize);\n    };\n    this.resizeItem = (item, size) => {\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (item.start < this.scrollOffset + this.scrollAdjustments) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.scrollOffset, {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(\n      () => [this.getIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      return notUndefined(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => notUndefined(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align) => {\n      const size = this.getSize();\n      if (align === \"auto\") {\n        if (toOffset <= this.scrollOffset) {\n          align = \"start\";\n        } else if (toOffset >= this.scrollOffset + size) {\n          align = \"end\";\n        } else {\n          align = \"start\";\n        }\n      }\n      if (align === \"start\") {\n        toOffset = toOffset;\n      } else if (align === \"end\") {\n        toOffset = toOffset - size;\n      } else if (align === \"center\") {\n        toOffset = toOffset - size / 2;\n      }\n      const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n      const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n      const maxOffset = scrollSize - this.getSize();\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const measurement = notUndefined(this.getMeasurements()[index]);\n      if (align === \"auto\") {\n        if (measurement.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (measurement.start <= this.scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [this.scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? measurement.end + this.options.scrollPaddingEnd : measurement.start - this.options.scrollPaddingStart;\n      return [this.getOffsetForAlignment(toOffset, align), align];\n    };\n    this.isDynamicMode = () => this.measureElementCache.size > 0;\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null) {\n        clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      const [toOffset, align] = this.getOffsetForIndex(index, initialAlign);\n      this._scrollToOffset(toOffset, { adjustments: void 0, behavior });\n      if (behavior !== \"smooth\" && this.isDynamicMode()) {\n        this.scrollToIndexTimeoutId = setTimeout(() => {\n          this.scrollToIndexTimeoutId = null;\n          const elementInDOM = this.measureElementCache.has(\n            this.options.getItemKey(index)\n          );\n          if (elementInDOM) {\n            const [toOffset2] = this.getOffsetForIndex(index, align);\n            if (!approxEqual(toOffset2, this.scrollOffset)) {\n              this.scrollToIndex(index, { align, behavior });\n            }\n          } else {\n            this.scrollToIndex(index, { align, behavior });\n          }\n        });\n      }\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.scrollOffset + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else {\n        end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(\n          ...measurements.slice(-this.options.lanes).map((m) => m.end)\n        );\n      }\n      return end - this.options.scrollMargin + this.options.paddingEnd;\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n    this.scrollRect = this.options.initialRect;\n    this.scrollOffset = this.options.initialOffset;\n    this.measurementsCache = this.options.initialMeasurementsCache;\n    this.measurementsCache.forEach((item) => {\n      this.itemSizeCache.set(item.key, item.size);\n    });\n    this.maybeNotify();\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset\n}) {\n  const count = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  let endIndex = startIndex;\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n  return { startIndex, endIndex };\n}\nexport {\n  Virtualizer,\n  approxEqual,\n  defaultKeyExtractor,\n  defaultRangeExtractor,\n  elementScroll,\n  measureElement,\n  memo,\n  notUndefined,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll\n};\n//# sourceMappingURL=index.js.map\n",
      "start": 1714082883080,
      "end": 1714082883081,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1714082883081,
      "end": 1714082883081,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { memo, notUndefined, approxEqual } from \"./utils.js\";\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(element.getBoundingClientRect());\n  if (typeof ResizeObserver === \"undefined\") {\n    return () => {\n    };\n  }\n  const observer = new ResizeObserver((entries) => {\n    const entry = entries[0];\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n      const box = entry.borderBoxSize[0];\n      if (box) {\n        handler({ width: box.inlineSize, height: box.blockSize });\n        return;\n      }\n    }\n    handler(element.getBoundingClientRect());\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, {\n    passive: true\n  });\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb(element[instance.options.horizontal ? \"scrollLeft\" : \"scrollTop\"]);\n  };\n  handler();\n  element.addEventListener(\"scroll\", handler, {\n    passive: true\n  });\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n  };\n};\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb(element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"]);\n  };\n  handler();\n  element.addEventListener(\"scroll\", handler, {\n    passive: true\n  });\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]\n  );\n};\nconst windowScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.isScrolling = false;\n    this.isScrollingTimeoutId = null;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.measureElementCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        } else if (typeof ResizeObserver !== \"undefined\") {\n          return _ro = new ResizeObserver((entries) => {\n            entries.forEach((entry) => {\n              this._measureElement(entry.target, entry);\n            });\n          });\n        } else {\n          return null;\n        }\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.disconnect();\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\")\n          delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        scrollingDelay: 150,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = memo(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key: false,\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.scrollElement = null;\n    };\n    this._didMount = () => {\n      this.measureElementCache.forEach(this.observer.observe);\n      return () => {\n        this.observer.disconnect();\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      const scrollElement = this.options.getScrollElement();\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        this.scrollElement = scrollElement;\n        this._scrollToOffset(this.scrollOffset, {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset) => {\n            this.scrollAdjustments = 0;\n            if (this.scrollOffset === offset) {\n              return;\n            }\n            if (this.isScrollingTimeoutId !== null) {\n              clearTimeout(this.isScrollingTimeoutId);\n              this.isScrollingTimeoutId = null;\n            }\n            this.isScrolling = true;\n            this.scrollDirection = this.scrollOffset < offset ? \"forward\" : \"backward\";\n            this.scrollOffset = offset;\n            this.maybeNotify();\n            this.isScrollingTimeoutId = setTimeout(() => {\n              this.isScrollingTimeoutId = null;\n              this.isScrolling = false;\n              this.scrollDirection = null;\n              this.maybeNotify();\n            }, this.options.scrollingDelay);\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.memoOptions = memo(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey\n      ],\n      (count, paddingStart, scrollMargin, getItemKey) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurements = memo(\n      () => [this.memoOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey }, itemSizeCache) => {\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key: false,\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = memo(\n      () => [this.getMeasurements(), this.getSize(), this.scrollOffset],\n      (measurements, outerSize, scrollOffset) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset\n        }) : null;\n      },\n      {\n        key: false,\n        debug: () => this.options.debug\n      }\n    );\n    this.getIndexes = memo(\n      () => [\n        this.options.rangeExtractor,\n        this.calculateRange(),\n        this.options.overscan,\n        this.options.count\n      ],\n      (rangeExtractor, range, overscan, count) => {\n        return range === null ? [] : rangeExtractor({\n          ...range,\n          overscan,\n          count\n        });\n      },\n      {\n        key: false,\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const item = this.measurementsCache[this.indexFromElement(node)];\n      if (!item || !node.isConnected) {\n        this.measureElementCache.forEach((cached, key) => {\n          if (cached === node) {\n            this.observer.unobserve(node);\n            this.measureElementCache.delete(key);\n          }\n        });\n        return;\n      }\n      const prevNode = this.measureElementCache.get(item.key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.measureElementCache.set(item.key, node);\n      }\n      const measuredItemSize = this.options.measureElement(node, entry, this);\n      this.resizeItem(item, measuredItemSize);\n    };\n    this.resizeItem = (item, size) => {\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (item.start < this.scrollOffset + this.scrollAdjustments) {\n          if (false) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.scrollOffset, {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(\n      () => [this.getIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key: false,\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      return notUndefined(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => notUndefined(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align) => {\n      const size = this.getSize();\n      if (align === \"auto\") {\n        if (toOffset <= this.scrollOffset) {\n          align = \"start\";\n        } else if (toOffset >= this.scrollOffset + size) {\n          align = \"end\";\n        } else {\n          align = \"start\";\n        }\n      }\n      if (align === \"start\") {\n        toOffset = toOffset;\n      } else if (align === \"end\") {\n        toOffset = toOffset - size;\n      } else if (align === \"center\") {\n        toOffset = toOffset - size / 2;\n      }\n      const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n      const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n      const maxOffset = scrollSize - this.getSize();\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const measurement = notUndefined(this.getMeasurements()[index]);\n      if (align === \"auto\") {\n        if (measurement.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (measurement.start <= this.scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [this.scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? measurement.end + this.options.scrollPaddingEnd : measurement.start - this.options.scrollPaddingStart;\n      return [this.getOffsetForAlignment(toOffset, align), align];\n    };\n    this.isDynamicMode = () => this.measureElementCache.size > 0;\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null) {\n        clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      const [toOffset, align] = this.getOffsetForIndex(index, initialAlign);\n      this._scrollToOffset(toOffset, { adjustments: void 0, behavior });\n      if (behavior !== \"smooth\" && this.isDynamicMode()) {\n        this.scrollToIndexTimeoutId = setTimeout(() => {\n          this.scrollToIndexTimeoutId = null;\n          const elementInDOM = this.measureElementCache.has(\n            this.options.getItemKey(index)\n          );\n          if (elementInDOM) {\n            const [toOffset2] = this.getOffsetForIndex(index, align);\n            if (!approxEqual(toOffset2, this.scrollOffset)) {\n              this.scrollToIndex(index, { align, behavior });\n            }\n          } else {\n            this.scrollToIndex(index, { align, behavior });\n          }\n        });\n      }\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.scrollOffset + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else {\n        end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(\n          ...measurements.slice(-this.options.lanes).map((m) => m.end)\n        );\n      }\n      return end - this.options.scrollMargin + this.options.paddingEnd;\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n    this.scrollRect = this.options.initialRect;\n    this.scrollOffset = this.options.initialOffset;\n    this.measurementsCache = this.options.initialMeasurementsCache;\n    this.measurementsCache.forEach((item) => {\n      this.itemSizeCache.set(item.key, item.size);\n    });\n    this.maybeNotify();\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset\n}) {\n  const count = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  let endIndex = startIndex;\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n  return { startIndex, endIndex };\n}\nexport {\n  Virtualizer,\n  approxEqual,\n  defaultKeyExtractor,\n  defaultRangeExtractor,\n  elementScroll,\n  measureElement,\n  memo,\n  notUndefined,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll\n};\n",
      "start": 1714082883081,
      "end": 1714082883161,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/omarmartin/Documents/DAW/arthub-project-DAW/frontendV3/node_modules/@tanstack/virtual-core/dist/esm/index.js\"],\n  \"sourcesContent\": [\"import { memo, notUndefined, approxEqual } from \\\"./utils.js\\\";\\nconst defaultKeyExtractor = (index) => index;\\nconst defaultRangeExtractor = (range) => {\\n  const start = Math.max(range.startIndex - range.overscan, 0);\\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\\n  const arr = [];\\n  for (let i = start; i <= end; i++) {\\n    arr.push(i);\\n  }\\n  return arr;\\n};\\nconst observeElementRect = (instance, cb) => {\\n  const element = instance.scrollElement;\\n  if (!element) {\\n    return;\\n  }\\n  const handler = (rect) => {\\n    const { width, height } = rect;\\n    cb({ width: Math.round(width), height: Math.round(height) });\\n  };\\n  handler(element.getBoundingClientRect());\\n  if (typeof ResizeObserver === \\\"undefined\\\") {\\n    return () => {\\n    };\\n  }\\n  const observer = new ResizeObserver((entries) => {\\n    const entry = entries[0];\\n    if (entry == null ? void 0 : entry.borderBoxSize) {\\n      const box = entry.borderBoxSize[0];\\n      if (box) {\\n        handler({ width: box.inlineSize, height: box.blockSize });\\n        return;\\n      }\\n    }\\n    handler(element.getBoundingClientRect());\\n  });\\n  observer.observe(element, { box: \\\"border-box\\\" });\\n  return () => {\\n    observer.unobserve(element);\\n  };\\n};\\nconst observeWindowRect = (instance, cb) => {\\n  const element = instance.scrollElement;\\n  if (!element) {\\n    return;\\n  }\\n  const handler = () => {\\n    cb({ width: element.innerWidth, height: element.innerHeight });\\n  };\\n  handler();\\n  element.addEventListener(\\\"resize\\\", handler, {\\n    passive: true\\n  });\\n  return () => {\\n    element.removeEventListener(\\\"resize\\\", handler);\\n  };\\n};\\nconst observeElementOffset = (instance, cb) => {\\n  const element = instance.scrollElement;\\n  if (!element) {\\n    return;\\n  }\\n  const handler = () => {\\n    cb(element[instance.options.horizontal ? \\\"scrollLeft\\\" : \\\"scrollTop\\\"]);\\n  };\\n  handler();\\n  element.addEventListener(\\\"scroll\\\", handler, {\\n    passive: true\\n  });\\n  return () => {\\n    element.removeEventListener(\\\"scroll\\\", handler);\\n  };\\n};\\nconst observeWindowOffset = (instance, cb) => {\\n  const element = instance.scrollElement;\\n  if (!element) {\\n    return;\\n  }\\n  const handler = () => {\\n    cb(element[instance.options.horizontal ? \\\"scrollX\\\" : \\\"scrollY\\\"]);\\n  };\\n  handler();\\n  element.addEventListener(\\\"scroll\\\", handler, {\\n    passive: true\\n  });\\n  return () => {\\n    element.removeEventListener(\\\"scroll\\\", handler);\\n  };\\n};\\nconst measureElement = (element, entry, instance) => {\\n  if (entry == null ? void 0 : entry.borderBoxSize) {\\n    const box = entry.borderBoxSize[0];\\n    if (box) {\\n      const size = Math.round(\\n        box[instance.options.horizontal ? \\\"inlineSize\\\" : \\\"blockSize\\\"]\\n      );\\n      return size;\\n    }\\n  }\\n  return Math.round(\\n    element.getBoundingClientRect()[instance.options.horizontal ? \\\"width\\\" : \\\"height\\\"]\\n  );\\n};\\nconst windowScroll = (offset, {\\n  adjustments = 0,\\n  behavior\\n}, instance) => {\\n  var _a, _b;\\n  const toOffset = offset + adjustments;\\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\\n    [instance.options.horizontal ? \\\"left\\\" : \\\"top\\\"]: toOffset,\\n    behavior\\n  });\\n};\\nconst elementScroll = (offset, {\\n  adjustments = 0,\\n  behavior\\n}, instance) => {\\n  var _a, _b;\\n  const toOffset = offset + adjustments;\\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\\n    [instance.options.horizontal ? \\\"left\\\" : \\\"top\\\"]: toOffset,\\n    behavior\\n  });\\n};\\nclass Virtualizer {\\n  constructor(opts) {\\n    this.unsubs = [];\\n    this.scrollElement = null;\\n    this.isScrolling = false;\\n    this.isScrollingTimeoutId = null;\\n    this.scrollToIndexTimeoutId = null;\\n    this.measurementsCache = [];\\n    this.itemSizeCache = /* @__PURE__ */ new Map();\\n    this.pendingMeasuredCacheIndexes = [];\\n    this.scrollDirection = null;\\n    this.scrollAdjustments = 0;\\n    this.measureElementCache = /* @__PURE__ */ new Map();\\n    this.observer = /* @__PURE__ */ (() => {\\n      let _ro = null;\\n      const get = () => {\\n        if (_ro) {\\n          return _ro;\\n        } else if (typeof ResizeObserver !== \\\"undefined\\\") {\\n          return _ro = new ResizeObserver((entries) => {\\n            entries.forEach((entry) => {\\n              this._measureElement(entry.target, entry);\\n            });\\n          });\\n        } else {\\n          return null;\\n        }\\n      };\\n      return {\\n        disconnect: () => {\\n          var _a;\\n          return (_a = get()) == null ? void 0 : _a.disconnect();\\n        },\\n        observe: (target) => {\\n          var _a;\\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \\\"border-box\\\" });\\n        },\\n        unobserve: (target) => {\\n          var _a;\\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\\n        }\\n      };\\n    })();\\n    this.range = null;\\n    this.setOptions = (opts2) => {\\n      Object.entries(opts2).forEach(([key, value]) => {\\n        if (typeof value === \\\"undefined\\\")\\n          delete opts2[key];\\n      });\\n      this.options = {\\n        debug: false,\\n        initialOffset: 0,\\n        overscan: 1,\\n        paddingStart: 0,\\n        paddingEnd: 0,\\n        scrollPaddingStart: 0,\\n        scrollPaddingEnd: 0,\\n        horizontal: false,\\n        getItemKey: defaultKeyExtractor,\\n        rangeExtractor: defaultRangeExtractor,\\n        onChange: () => {\\n        },\\n        measureElement,\\n        initialRect: { width: 0, height: 0 },\\n        scrollMargin: 0,\\n        gap: 0,\\n        scrollingDelay: 150,\\n        indexAttribute: \\\"data-index\\\",\\n        initialMeasurementsCache: [],\\n        lanes: 1,\\n        ...opts2\\n      };\\n    };\\n    this.notify = (sync) => {\\n      var _a, _b;\\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\\n    };\\n    this.maybeNotify = memo(\\n      () => {\\n        this.calculateRange();\\n        return [\\n          this.isScrolling,\\n          this.range ? this.range.startIndex : null,\\n          this.range ? this.range.endIndex : null\\n        ];\\n      },\\n      (isScrolling) => {\\n        this.notify(isScrolling);\\n      },\\n      {\\n        key: process.env.NODE_ENV !== \\\"production\\\" && \\\"maybeNotify\\\",\\n        debug: () => this.options.debug,\\n        initialDeps: [\\n          this.isScrolling,\\n          this.range ? this.range.startIndex : null,\\n          this.range ? this.range.endIndex : null\\n        ]\\n      }\\n    );\\n    this.cleanup = () => {\\n      this.unsubs.filter(Boolean).forEach((d) => d());\\n      this.unsubs = [];\\n      this.scrollElement = null;\\n    };\\n    this._didMount = () => {\\n      this.measureElementCache.forEach(this.observer.observe);\\n      return () => {\\n        this.observer.disconnect();\\n        this.cleanup();\\n      };\\n    };\\n    this._willUpdate = () => {\\n      const scrollElement = this.options.getScrollElement();\\n      if (this.scrollElement !== scrollElement) {\\n        this.cleanup();\\n        this.scrollElement = scrollElement;\\n        this._scrollToOffset(this.scrollOffset, {\\n          adjustments: void 0,\\n          behavior: void 0\\n        });\\n        this.unsubs.push(\\n          this.options.observeElementRect(this, (rect) => {\\n            this.scrollRect = rect;\\n            this.maybeNotify();\\n          })\\n        );\\n        this.unsubs.push(\\n          this.options.observeElementOffset(this, (offset) => {\\n            this.scrollAdjustments = 0;\\n            if (this.scrollOffset === offset) {\\n              return;\\n            }\\n            if (this.isScrollingTimeoutId !== null) {\\n              clearTimeout(this.isScrollingTimeoutId);\\n              this.isScrollingTimeoutId = null;\\n            }\\n            this.isScrolling = true;\\n            this.scrollDirection = this.scrollOffset < offset ? \\\"forward\\\" : \\\"backward\\\";\\n            this.scrollOffset = offset;\\n            this.maybeNotify();\\n            this.isScrollingTimeoutId = setTimeout(() => {\\n              this.isScrollingTimeoutId = null;\\n              this.isScrolling = false;\\n              this.scrollDirection = null;\\n              this.maybeNotify();\\n            }, this.options.scrollingDelay);\\n          })\\n        );\\n      }\\n    };\\n    this.getSize = () => {\\n      return this.scrollRect[this.options.horizontal ? \\\"width\\\" : \\\"height\\\"];\\n    };\\n    this.memoOptions = memo(\\n      () => [\\n        this.options.count,\\n        this.options.paddingStart,\\n        this.options.scrollMargin,\\n        this.options.getItemKey\\n      ],\\n      (count, paddingStart, scrollMargin, getItemKey) => {\\n        this.pendingMeasuredCacheIndexes = [];\\n        return {\\n          count,\\n          paddingStart,\\n          scrollMargin,\\n          getItemKey\\n        };\\n      },\\n      {\\n        key: false\\n      }\\n    );\\n    this.getFurthestMeasurement = (measurements, index) => {\\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\\n      const furthestMeasurements = /* @__PURE__ */ new Map();\\n      for (let m = index - 1; m >= 0; m--) {\\n        const measurement = measurements[m];\\n        if (furthestMeasurementsFound.has(measurement.lane)) {\\n          continue;\\n        }\\n        const previousFurthestMeasurement = furthestMeasurements.get(\\n          measurement.lane\\n        );\\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\\n          furthestMeasurements.set(measurement.lane, measurement);\\n        } else if (measurement.end < previousFurthestMeasurement.end) {\\n          furthestMeasurementsFound.set(measurement.lane, true);\\n        }\\n        if (furthestMeasurementsFound.size === this.options.lanes) {\\n          break;\\n        }\\n      }\\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\\n        if (a.end === b.end) {\\n          return a.index - b.index;\\n        }\\n        return a.end - b.end;\\n      })[0] : void 0;\\n    };\\n    this.getMeasurements = memo(\\n      () => [this.memoOptions(), this.itemSizeCache],\\n      ({ count, paddingStart, scrollMargin, getItemKey }, itemSizeCache) => {\\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\\n        this.pendingMeasuredCacheIndexes = [];\\n        const measurements = this.measurementsCache.slice(0, min);\\n        for (let i = min; i < count; i++) {\\n          const key = getItemKey(i);\\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\\n          const measuredSize = itemSizeCache.get(key);\\n          const size = typeof measuredSize === \\\"number\\\" ? measuredSize : this.options.estimateSize(i);\\n          const end = start + size;\\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\\n          measurements[i] = {\\n            index: i,\\n            start,\\n            size,\\n            end,\\n            key,\\n            lane\\n          };\\n        }\\n        this.measurementsCache = measurements;\\n        return measurements;\\n      },\\n      {\\n        key: process.env.NODE_ENV !== \\\"production\\\" && \\\"getMeasurements\\\",\\n        debug: () => this.options.debug\\n      }\\n    );\\n    this.calculateRange = memo(\\n      () => [this.getMeasurements(), this.getSize(), this.scrollOffset],\\n      (measurements, outerSize, scrollOffset) => {\\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\\n          measurements,\\n          outerSize,\\n          scrollOffset\\n        }) : null;\\n      },\\n      {\\n        key: process.env.NODE_ENV !== \\\"production\\\" && \\\"calculateRange\\\",\\n        debug: () => this.options.debug\\n      }\\n    );\\n    this.getIndexes = memo(\\n      () => [\\n        this.options.rangeExtractor,\\n        this.calculateRange(),\\n        this.options.overscan,\\n        this.options.count\\n      ],\\n      (rangeExtractor, range, overscan, count) => {\\n        return range === null ? [] : rangeExtractor({\\n          ...range,\\n          overscan,\\n          count\\n        });\\n      },\\n      {\\n        key: process.env.NODE_ENV !== \\\"production\\\" && \\\"getIndexes\\\",\\n        debug: () => this.options.debug\\n      }\\n    );\\n    this.indexFromElement = (node) => {\\n      const attributeName = this.options.indexAttribute;\\n      const indexStr = node.getAttribute(attributeName);\\n      if (!indexStr) {\\n        console.warn(\\n          `Missing attribute name '${attributeName}={index}' on measured element.`\\n        );\\n        return -1;\\n      }\\n      return parseInt(indexStr, 10);\\n    };\\n    this._measureElement = (node, entry) => {\\n      const item = this.measurementsCache[this.indexFromElement(node)];\\n      if (!item || !node.isConnected) {\\n        this.measureElementCache.forEach((cached, key) => {\\n          if (cached === node) {\\n            this.observer.unobserve(node);\\n            this.measureElementCache.delete(key);\\n          }\\n        });\\n        return;\\n      }\\n      const prevNode = this.measureElementCache.get(item.key);\\n      if (prevNode !== node) {\\n        if (prevNode) {\\n          this.observer.unobserve(prevNode);\\n        }\\n        this.observer.observe(node);\\n        this.measureElementCache.set(item.key, node);\\n      }\\n      const measuredItemSize = this.options.measureElement(node, entry, this);\\n      this.resizeItem(item, measuredItemSize);\\n    };\\n    this.resizeItem = (item, size) => {\\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\\n      const delta = size - itemSize;\\n      if (delta !== 0) {\\n        if (item.start < this.scrollOffset + this.scrollAdjustments) {\\n          if (process.env.NODE_ENV !== \\\"production\\\" && this.options.debug) {\\n            console.info(\\\"correction\\\", delta);\\n          }\\n          this._scrollToOffset(this.scrollOffset, {\\n            adjustments: this.scrollAdjustments += delta,\\n            behavior: void 0\\n          });\\n        }\\n        this.pendingMeasuredCacheIndexes.push(item.index);\\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\\n        this.notify(false);\\n      }\\n    };\\n    this.measureElement = (node) => {\\n      if (!node) {\\n        return;\\n      }\\n      this._measureElement(node, void 0);\\n    };\\n    this.getVirtualItems = memo(\\n      () => [this.getIndexes(), this.getMeasurements()],\\n      (indexes, measurements) => {\\n        const virtualItems = [];\\n        for (let k = 0, len = indexes.length; k < len; k++) {\\n          const i = indexes[k];\\n          const measurement = measurements[i];\\n          virtualItems.push(measurement);\\n        }\\n        return virtualItems;\\n      },\\n      {\\n        key: process.env.NODE_ENV !== \\\"production\\\" && \\\"getIndexes\\\",\\n        debug: () => this.options.debug\\n      }\\n    );\\n    this.getVirtualItemForOffset = (offset) => {\\n      const measurements = this.getMeasurements();\\n      return notUndefined(\\n        measurements[findNearestBinarySearch(\\n          0,\\n          measurements.length - 1,\\n          (index) => notUndefined(measurements[index]).start,\\n          offset\\n        )]\\n      );\\n    };\\n    this.getOffsetForAlignment = (toOffset, align) => {\\n      const size = this.getSize();\\n      if (align === \\\"auto\\\") {\\n        if (toOffset <= this.scrollOffset) {\\n          align = \\\"start\\\";\\n        } else if (toOffset >= this.scrollOffset + size) {\\n          align = \\\"end\\\";\\n        } else {\\n          align = \\\"start\\\";\\n        }\\n      }\\n      if (align === \\\"start\\\") {\\n        toOffset = toOffset;\\n      } else if (align === \\\"end\\\") {\\n        toOffset = toOffset - size;\\n      } else if (align === \\\"center\\\") {\\n        toOffset = toOffset - size / 2;\\n      }\\n      const scrollSizeProp = this.options.horizontal ? \\\"scrollWidth\\\" : \\\"scrollHeight\\\";\\n      const scrollSize = this.scrollElement ? \\\"document\\\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\\n      const maxOffset = scrollSize - this.getSize();\\n      return Math.max(Math.min(maxOffset, toOffset), 0);\\n    };\\n    this.getOffsetForIndex = (index, align = \\\"auto\\\") => {\\n      index = Math.max(0, Math.min(index, this.options.count - 1));\\n      const measurement = notUndefined(this.getMeasurements()[index]);\\n      if (align === \\\"auto\\\") {\\n        if (measurement.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd) {\\n          align = \\\"end\\\";\\n        } else if (measurement.start <= this.scrollOffset + this.options.scrollPaddingStart) {\\n          align = \\\"start\\\";\\n        } else {\\n          return [this.scrollOffset, align];\\n        }\\n      }\\n      const toOffset = align === \\\"end\\\" ? measurement.end + this.options.scrollPaddingEnd : measurement.start - this.options.scrollPaddingStart;\\n      return [this.getOffsetForAlignment(toOffset, align), align];\\n    };\\n    this.isDynamicMode = () => this.measureElementCache.size > 0;\\n    this.cancelScrollToIndex = () => {\\n      if (this.scrollToIndexTimeoutId !== null) {\\n        clearTimeout(this.scrollToIndexTimeoutId);\\n        this.scrollToIndexTimeoutId = null;\\n      }\\n    };\\n    this.scrollToOffset = (toOffset, { align = \\\"start\\\", behavior } = {}) => {\\n      this.cancelScrollToIndex();\\n      if (behavior === \\\"smooth\\\" && this.isDynamicMode()) {\\n        console.warn(\\n          \\\"The `smooth` scroll behavior is not fully supported with dynamic size.\\\"\\n        );\\n      }\\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\\n        adjustments: void 0,\\n        behavior\\n      });\\n    };\\n    this.scrollToIndex = (index, { align: initialAlign = \\\"auto\\\", behavior } = {}) => {\\n      index = Math.max(0, Math.min(index, this.options.count - 1));\\n      this.cancelScrollToIndex();\\n      if (behavior === \\\"smooth\\\" && this.isDynamicMode()) {\\n        console.warn(\\n          \\\"The `smooth` scroll behavior is not fully supported with dynamic size.\\\"\\n        );\\n      }\\n      const [toOffset, align] = this.getOffsetForIndex(index, initialAlign);\\n      this._scrollToOffset(toOffset, { adjustments: void 0, behavior });\\n      if (behavior !== \\\"smooth\\\" && this.isDynamicMode()) {\\n        this.scrollToIndexTimeoutId = setTimeout(() => {\\n          this.scrollToIndexTimeoutId = null;\\n          const elementInDOM = this.measureElementCache.has(\\n            this.options.getItemKey(index)\\n          );\\n          if (elementInDOM) {\\n            const [toOffset2] = this.getOffsetForIndex(index, align);\\n            if (!approxEqual(toOffset2, this.scrollOffset)) {\\n              this.scrollToIndex(index, { align, behavior });\\n            }\\n          } else {\\n            this.scrollToIndex(index, { align, behavior });\\n          }\\n        });\\n      }\\n    };\\n    this.scrollBy = (delta, { behavior } = {}) => {\\n      this.cancelScrollToIndex();\\n      if (behavior === \\\"smooth\\\" && this.isDynamicMode()) {\\n        console.warn(\\n          \\\"The `smooth` scroll behavior is not fully supported with dynamic size.\\\"\\n        );\\n      }\\n      this._scrollToOffset(this.scrollOffset + delta, {\\n        adjustments: void 0,\\n        behavior\\n      });\\n    };\\n    this.getTotalSize = () => {\\n      var _a;\\n      const measurements = this.getMeasurements();\\n      let end;\\n      if (measurements.length === 0) {\\n        end = this.options.paddingStart;\\n      } else {\\n        end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(\\n          ...measurements.slice(-this.options.lanes).map((m) => m.end)\\n        );\\n      }\\n      return end - this.options.scrollMargin + this.options.paddingEnd;\\n    };\\n    this._scrollToOffset = (offset, {\\n      adjustments,\\n      behavior\\n    }) => {\\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\\n    };\\n    this.measure = () => {\\n      this.itemSizeCache = /* @__PURE__ */ new Map();\\n      this.notify(false);\\n    };\\n    this.setOptions(opts);\\n    this.scrollRect = this.options.initialRect;\\n    this.scrollOffset = this.options.initialOffset;\\n    this.measurementsCache = this.options.initialMeasurementsCache;\\n    this.measurementsCache.forEach((item) => {\\n      this.itemSizeCache.set(item.key, item.size);\\n    });\\n    this.maybeNotify();\\n  }\\n}\\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\\n  while (low <= high) {\\n    const middle = (low + high) / 2 | 0;\\n    const currentValue = getCurrentValue(middle);\\n    if (currentValue < value) {\\n      low = middle + 1;\\n    } else if (currentValue > value) {\\n      high = middle - 1;\\n    } else {\\n      return middle;\\n    }\\n  }\\n  if (low > 0) {\\n    return low - 1;\\n  } else {\\n    return 0;\\n  }\\n};\\nfunction calculateRange({\\n  measurements,\\n  outerSize,\\n  scrollOffset\\n}) {\\n  const count = measurements.length - 1;\\n  const getOffset = (index) => measurements[index].start;\\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\\n  let endIndex = startIndex;\\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\\n    endIndex++;\\n  }\\n  return { startIndex, endIndex };\\n}\\nexport {\\n  Virtualizer,\\n  approxEqual,\\n  defaultKeyExtractor,\\n  defaultRangeExtractor,\\n  elementScroll,\\n  measureElement,\\n  memo,\\n  notUndefined,\\n  observeElementOffset,\\n  observeElementRect,\\n  observeWindowOffset,\\n  observeWindowRect,\\n  windowScroll\\n};\\n//# sourceMappingURL=index.js.map\\n\"],\n  \"mappings\": \"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\",\n  \"names\": []\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1714082883161,
      "end": 1714082883161,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714082883161,
      "end": 1714082883161,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714082883161,
      "end": 1714082883162,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714082883162,
      "end": 1714082883162,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714082883162,
      "end": 1714082883163,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714082883163,
      "end": 1714082883163,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714082883163,
      "end": 1714082883163,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1714082883163,
      "end": 1714082883163,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1714082883163,
      "end": 1714082883163,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1714082883163,
      "end": 1714082883163,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1714082883163,
      "end": 1714082883163,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1714082883163,
      "end": 1714082883163,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1714082883163,
      "end": 1714082883163,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1714082883163,
      "end": 1714082883163,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1714082883163,
      "end": 1714082883163,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714082883163,
      "end": 1714082883163,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714082883163,
      "end": 1714082883163,
      "order": "normal"
    }
  ]
}
